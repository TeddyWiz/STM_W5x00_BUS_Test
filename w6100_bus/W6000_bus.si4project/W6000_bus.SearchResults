---- delay Matches (32 in 13 files) ----
default_ipv4_update in dhcpv4.c (io6Library\Internet\DHCP4) : 
   setSYCR0(SYCR0_RST);
   getSYCR0(); // for delay
   default_ipv4_assign();
   setSHAR(DHCPv4_CHADDR);
}
default_ipv4_conflict in dhcpv4.c (io6Library\Internet\DHCP4) : 
	setSYCR0(SYCR0_RST);
	getSYCR0(); // for delay
	setSHAR(DHCPv4_CHADDR);
}

{anonSAI_TypeDef} in stm32h723xx.h (Drivers\CMSIS\Device\ST\STM32H7xx\Include) : 
  __IO uint32_t PDMCR;         /*!< SAI PDM control register,          Address offset: 0x44 */
  __IO uint32_t PDMDLY;        /*!< SAI PDM delay register,            Address offset: 0x48 */
} SAI_TypeDef;

typedef struct
stm32h723xx.h (Drivers\CMSIS\Device\ST\STM32H7xx\Include) line 10825 : 
#define FLASH_ACR_WRHIGHFREQ_Msk             (0x3UL << FLASH_ACR_WRHIGHFREQ_Pos)  /*!< 0x00000030 */
#define FLASH_ACR_WRHIGHFREQ                 FLASH_ACR_WRHIGHFREQ_Msk             /*!< Flash signal delay */
#define FLASH_ACR_WRHIGHFREQ_0               (0x1UL << FLASH_ACR_WRHIGHFREQ_Pos)  /*!< 0x00000010 */
#define FLASH_ACR_WRHIGHFREQ_1               (0x2UL << FLASH_ACR_WRHIGHFREQ_Pos)  /*!< 0x00000020 */

stm32h723xx.h (Drivers\CMSIS\Device\ST\STM32H7xx\Include) line 11453 : 
#define FMC_PCR_TCLR_Msk           (0xFUL << FMC_PCR_TCLR_Pos)                 /*!< 0x00001E00 */
#define FMC_PCR_TCLR               FMC_PCR_TCLR_Msk                            /*!<TCLR[3:0] bits (CLE to RE delay)          */
#define FMC_PCR_TCLR_0             (0x1UL << FMC_PCR_TCLR_Pos)                  /*!< 0x00000200 */
#define FMC_PCR_TCLR_1             (0x2UL << FMC_PCR_TCLR_Pos)                  /*!< 0x00000400 */
#define FMC_PCR_TCLR_2             (0x4UL << FMC_PCR_TCLR_Pos)                  /*!< 0x00000800 */
stm32h723xx.h (Drivers\CMSIS\Device\ST\STM32H7xx\Include) line 11461 : 
#define FMC_PCR_TAR_Msk            (0xFUL << FMC_PCR_TAR_Pos)                  /*!< 0x0001E000 */
#define FMC_PCR_TAR                FMC_PCR_TAR_Msk                             /*!<TAR[3:0] bits (ALE to RE delay)           */
#define FMC_PCR_TAR_0              (0x1UL << FMC_PCR_TAR_Pos)                   /*!< 0x00002000 */
#define FMC_PCR_TAR_1              (0x2UL << FMC_PCR_TAR_Pos)                   /*!< 0x00004000 */
#define FMC_PCR_TAR_2              (0x4UL << FMC_PCR_TAR_Pos)                   /*!< 0x00008000 */
stm32h723xx.h (Drivers\CMSIS\Device\ST\STM32H7xx\Include) line 11676 : 
#define FMC_SDTRx_TRC_Msk          (0xFUL << FMC_SDTRx_TRC_Pos)                /*!< 0x0000F000 */
#define FMC_SDTRx_TRC              FMC_SDTRx_TRC_Msk                           /*!<TRC[2:0] bits (Row cycle delay) */
#define FMC_SDTRx_TRC_0            (0x1UL << FMC_SDTRx_TRC_Pos)                 /*!< 0x00001000 */
#define FMC_SDTRx_TRC_1            (0x2UL << FMC_SDTRx_TRC_Pos)                 /*!< 0x00002000 */
#define FMC_SDTRx_TRC_2            (0x4UL << FMC_SDTRx_TRC_Pos)                 /*!< 0x00004000 */
stm32h723xx.h (Drivers\CMSIS\Device\ST\STM32H7xx\Include) line 11683 : 
#define FMC_SDTRx_TWR_Msk          (0xFUL << FMC_SDTRx_TWR_Pos)                /*!< 0x000F0000 */
#define FMC_SDTRx_TWR              FMC_SDTRx_TWR_Msk                           /*!<TRC[2:0] bits (Write recovery delay) */
#define FMC_SDTRx_TWR_0            (0x1UL << FMC_SDTRx_TWR_Pos)                 /*!< 0x00010000 */
#define FMC_SDTRx_TWR_1            (0x2UL << FMC_SDTRx_TWR_Pos)                 /*!< 0x00020000 */
#define FMC_SDTRx_TWR_2            (0x4UL << FMC_SDTRx_TWR_Pos)                 /*!< 0x00040000 */
stm32h723xx.h (Drivers\CMSIS\Device\ST\STM32H7xx\Include) line 11690 : 
#define FMC_SDTRx_TRP_Msk          (0xFUL << FMC_SDTRx_TRP_Pos)                /*!< 0x00F00000 */
#define FMC_SDTRx_TRP              FMC_SDTRx_TRP_Msk                           /*!<TRP[2:0] bits (Row precharge delay) */
#define FMC_SDTRx_TRP_0            (0x1UL << FMC_SDTRx_TRP_Pos)                 /*!< 0x00100000 */
#define FMC_SDTRx_TRP_1            (0x2UL << FMC_SDTRx_TRP_Pos)                 /*!< 0x00200000 */
#define FMC_SDTRx_TRP_2            (0x4UL << FMC_SDTRx_TRP_Pos)                 /*!< 0x00400000 */
stm32h723xx.h (Drivers\CMSIS\Device\ST\STM32H7xx\Include) line 11697 : 
#define FMC_SDTRx_TRCD_Msk         (0xFUL << FMC_SDTRx_TRCD_Pos)               /*!< 0x0F000000 */
#define FMC_SDTRx_TRCD             FMC_SDTRx_TRCD_Msk                          /*!<TRP[2:0] bits (Row to column delay) */
#define FMC_SDTRx_TRCD_0           (0x1UL << FMC_SDTRx_TRCD_Pos)                /*!< 0x01000000 */
#define FMC_SDTRx_TRCD_1           (0x2UL << FMC_SDTRx_TRCD_Pos)                /*!< 0x02000000 */
#define FMC_SDTRx_TRCD_2           (0x4UL << FMC_SDTRx_TRCD_Pos)                /*!< 0x04000000 */
stm32h723xx.h (Drivers\CMSIS\Device\ST\STM32H7xx\Include) line 18155 : 
#define DLYB_CFGR_UNIT_Msk      (0x7FUL << DLYB_CFGR_UNIT_Pos)                 /*!< 0x00007F00 */
#define DLYB_CFGR_UNIT          DLYB_CFGR_UNIT_Msk                             /*!<Delay Defines the delay of a Unit delay cell[6:0] */
#define DLYB_CFGR_UNIT_0        (0x01UL << DLYB_CFGR_UNIT_Pos)                  /*!< 0x00000100 */
#define DLYB_CFGR_UNIT_1        (0x02UL << DLYB_CFGR_UNIT_Pos)                  /*!< 0x00000200 */
#define DLYB_CFGR_UNIT_2        (0x04UL << DLYB_CFGR_UNIT_Pos)                  /*!< 0x00000400 */
stm32h7xx_hal.c (Drivers\STM32H7xx_HAL_Driver\Src) line 303 : 
      (+) Provide a tick value in millisecond
      (+) Provide a blocking delay in millisecond
      (+) Suspend the time base source interrupt
      (+) Resume the time base source interrupt
      (+) Get the HAL API driver version
stm32h7xx_hal.c (Drivers\STM32H7xx_HAL_Driver\Src) line 393 : 
/**
  * @brief This function provides minimum delay (in milliseconds) based
  *        on variable incremented.
  * @note In the default implementation , SysTick timer is the source of time base.
  *       It is used to generate interrupts at regular time intervals where uwTick
stm32h7xx_hal.c (Drivers\STM32H7xx_HAL_Driver\Src) line 400 : 
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
stm32h7xx_hal_flash_ex.h (Drivers\STM32H7xx_HAL_Driver\Inc) line 713 : 
  */
#define FLASH_PROGRAMMING_DELAY_0   0x00000000U            /*!< programming delay set for Flash running at 70 MHz or below          */
#define FLASH_PROGRAMMING_DELAY_1   FLASH_ACR_WRHIGHFREQ_0 /*!< programming delay set for Flash running between 70 MHz and 185 MHz  */
#define FLASH_PROGRAMMING_DELAY_2   FLASH_ACR_WRHIGHFREQ_1 /*!< programming delay set for Flash running between 185 MHz and 225 MHz */
#define FLASH_PROGRAMMING_DELAY_3   FLASH_ACR_WRHIGHFREQ   /*!< programming delay set for Flash at startup */
/**
  * @}
  */
stm32h7xx_hal_pwr.c (Drivers\STM32H7xx_HAL_Driver\Src) line 610 : 
  * @note   In System STOP mode, when the voltage regulator operates in low
  *         power mode, an additional startup delay is incurred when the system
  *         is waking up. By keeping the internal regulator ON during STOP mode,
  *         the consumption is higher although the startup time is reduced.
  * @retval None.
stm32h7xx_hal_pwr_ex.c (Drivers\STM32H7xx_HAL_Driver\Src) line 534 : 
  *         mode (LP) can be selected by LPDS register bit.
  * @note   The selected SVOS4 and SVOS5 levels add an additional startup delay
  *         when exiting from system Stop mode.
  * @retval HAL Status.
  */
stm32h7xx_hal_pwr_ex.c (Drivers\STM32H7xx_HAL_Driver\Src) line 683 : 
      power down mode when the device enters STOP mode. When the Flash memory is
      in power down mode, an additional startup delay is incurred when waking up
      from STOP mode.

    *** Wakeup Pins configuration ****
stm32h7xx_hal_pwr_ex.c (Drivers\STM32H7xx_HAL_Driver\Src) line 1584 : 
          function which configure the SVOS bit in PWR_CR1 register.
          The selected SVOS4 and SVOS5 levels add an additional startup delay
          when exiting from system Stop mode.
    -@- Refer to the product datasheets for more details.

stm32h7xx_hal_rcc.c (Drivers\STM32H7xx_HAL_Driver\Src) line 38 : 
    [..]
      A delay between an RCC peripheral clock enable and the effective peripheral
      enabling should be taken into account in order to manage the peripheral read/write
      from/to registers.
      (+) This delay depends on the peripheral mapping.
      (+) If peripheral is mapped on AHB: the delay is 2 AHB clock cycle
          after the clock enable bit is set on the hardware register
      (+) If peripheral is mapped on APB: the delay is 2 APB clock cycle
          after the clock enable bit is set on the hardware register

    [..]
stm32h7xx_hal_rcc.c (Drivers\STM32H7xx_HAL_Driver\Src) line 878 : 
  * @note   A switch from one clock source to another occurs only if the target
  *         clock source is ready (clock stable after start-up delay or PLL locked).
  *         If a clock source which is not yet ready is selected, the switch will
  *         occur when the clock source will be ready.
  *         You can use HAL_RCC_GetClockConfig() function to know which clock is
stm32h7xx_hal_tim.c (Drivers\STM32H7xx_HAL_Driver\Src) line 4300 : 
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  * @note  To output a waveform with a minimum delay user can enable the fast
  *        mode by calling the @ref __HAL_TIM_ENABLE_OCxFAST macro. Then CCx
  *        output is forced in response to the edge detection on TIx input,
  *        without taking in account the comparison.
{anonTIM_MasterConfigTypeDef} in stm32h7xx_hal_tim.h (Drivers\STM32H7xx_HAL_Driver\Inc) : 
                                        @note When the Master/slave mode is enabled, the effect of
                                        an event on the trigger input (TRGI) is delayed to allow a
                                        perfect synchronization between the current timer and its
                                        slaves (through TRGO). It is not mandatory in case of timer
                                        synchronization mode. */
stm32h7xx_hal_tim.h (Drivers\STM32H7xx_HAL_Driver\Inc) line 1657 : 
  *        on counter and CCRx values even when the trigger is ON. The minimum
  *        delay to activate CCx output when an active edge occurs on the
  *        trigger input is 5 clock cycles.
  * @retval None
  */
{anonFMC_NAND_InitTypeDef} in stm32h7xx_ll_fmc.h (Drivers\STM32H7xx_HAL_Driver\Inc) : 
  uint32_t TCLRSetupTime;          /*!< Defines the number of HCLK cycles to configure the
                                        delay between CLE low and RE low.
                                        This parameter can be a value between Min_Data = 0 and Max_Data = 255  */

  uint32_t TARSetupTime;           /*!< Defines the number of HCLK cycles to configure the
                                        delay between ALE low and RE low.
                                        This parameter can be a number between Min_Data = 0 and Max_Data = 255 */
} FMC_NAND_InitTypeDef;

{anonFMC_SDRAM_InitTypeDef} in stm32h7xx_ll_fmc.h (Drivers\STM32H7xx_HAL_Driver\Inc) : 

  uint32_t ReadPipeDelay;               /*!< Define the delay in system clock cycles on read data path.
                                             This parameter can be a value of @ref FMC_SDRAM_Read_Pipe_Delay.    */
} FMC_SDRAM_InitTypeDef;

{anonFMC_SDRAM_TimingTypeDef} in stm32h7xx_ll_fmc.h (Drivers\STM32H7xx_HAL_Driver\Inc) : 
{
  uint32_t LoadToActiveDelay;            /*!< Defines the delay between a Load Mode Register command and
                                              an active or Refresh command in number of memory clock cycles.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  */

  uint32_t ExitSelfRefreshDelay;         /*!< Defines the delay from releasing the self refresh command to
                                              issuing the Activate command in number of memory clock cycles.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  */

{anonFMC_SDRAM_TimingTypeDef} in stm32h7xx_ll_fmc.h (Drivers\STM32H7xx_HAL_Driver\Inc) : 

  uint32_t RowCycleDelay;                /*!< Defines the delay between the Refresh command and the Activate command
                                              and the delay between two consecutive Refresh commands in number of
                                              memory clock cycles.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  */

{anonFMC_SDRAM_TimingTypeDef} in stm32h7xx_ll_fmc.h (Drivers\STM32H7xx_HAL_Driver\Inc) : 

  uint32_t RPDelay;                      /*!< Defines the delay between a Precharge Command and an other command
                                              in number of memory clock cycles.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  */

  uint32_t RCDDelay;                     /*!< Defines the delay between the Activate Command and a Read/Write
                                              command in number of memory clock cycles.
                                              This parameter can be a value between Min_Data = 1 and Max_Data = 16  */
} FMC_SDRAM_TimingTypeDef;
w6100.h (io6Library\Ethernet\W6100) line 2302 : 
 * @brief No Delayed Ack
 * @details When @ref Sn_MR_FPSH is set, It sends the ACK packet without delay as soon as a DATA packet is received from a peer.\n
 *          Otherwise, It sends the ACK packet after waiting the time set by @ref _Sn_RTR_. \n
 *          0 : Delayed ACK \n
 *          1 : No Delayed ACK \n
wizchip_sw_reset in wizchip_conf.c (io6Library\Ethernet) : 
   setSYCR0(SYCR0_RST);
   getSYCR0(); // for delay

   NETUNLOCK();

wizchip_conf.h (io6Library\Ethernet) line 653 : 
 *            // Need to wait stable reset time 60.3ms\n
 *            your_delay_function(60300);
 *          </code>
 */          
int8_t ctlwizchip(ctlwizchip_type cwtype, void* arg);
